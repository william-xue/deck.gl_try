# diff_lis 教学手册

> 建议先用 `node index.js` 与 `node hydrate_demo.js` 跑一遍示例，再结合本文逐段理解。

## 目录
- [1. 列表 Diff 与 LIS 教程](#列表-diff-与-lis-教程)
- [2. 客户端水合流程模拟](#客户端水合流程模拟)
- [3. 场景分析与扩展练习](#场景分析与扩展练习)
- [4. 延伸阅读与思考题](#延伸阅读与思考题)

## 列表 Diff 与 LIS 教程

对应文件：`diff_lis/index.js`

### 关键步骤速览
1. **双指针对齐头尾**：快速跳过完全一致的头部和尾部节点，复杂度 O(k)。
2. **中段索引映射**：用 `Map` 建立旧节点的索引表，方便 O(1) 查找。
3. **记录新节点位置序列**：把新列表中可复用的旧索引推入 `positionSequence`。
4. **求解 LIS**：在 `positionSequence` 中找到最长递增子序列，标记无需移动的节点。
5. **插入 / 删除 / 移动决策**：未命中 LIS 的旧节点 → 移动；新列表缺失的旧节点 → 删除；旧列表缺失的新节点 → 插入。

### 案例解析
- **案例 1：只有头尾一致，中间简单换位**
  - 重点观察头尾双指针如何缩小问题规模；
  - 中间两个元素调换位置，LIS 只包含 `"C"`，因此 `"B"` 需要移动。
- **案例 2：新增元素与位置调整并存**
  - 新列表中出现 `"F"`，旧列表没有 → 生成插入操作；
  - 旧列表中的 `"C"` 在新列表末尾 → 会被判断为“移动”；
  - 可联想到实时监控图表中新增一条曲线的场景。
- **案例 3：删除旧节点，保留部分顺序**
  - 旧列表 `"A"` 被保留，新列表缺失 `"D"` → 触发删除；
  - `"B"` 与 `"C"` 的顺序在新列表中保持递增，因此 LIS 为 `["A","B"]`，`"C"` 被移动。

### 自主练习
尝试向 `demoCases` 追加以下情境：
1. 旧列表存在重复 key（例如两个 `"A"`），观察算法如何处理异常；
2. 新列表为空数组，验证删除逻辑是否覆盖全部节点；
3. 超长列表（例如 1 万个节点），评估算法耗时，感受 O(n log n) 与 O(n²) 的差异。

## 客户端水合流程模拟

对应文件：`diff_lis/hydrate_demo.js`

### 水合阶段的三个核心问题
1. **节点能否复用？** —— 判断依据是元素类型或 key 是否一致；
2. **属性是否匹配？** —— 若值不同，执行“补丁”而非整节点替换；
3. **子节点顺序如何处理？** —— 优先尝试线性匹配，否则触发重排/补渲染。

### 案例解析
- **案例 1：完全同构，线性复用**
  - 输出全部是 “复用” 类操作，说明服务端/客户端一致 → 仅需绑定事件回调。
  - 以电力看板为例，首屏 SSR 提供当前电压、电流信息，客户端上来只需挂载交互。
- **案例 2：属性与文本不一致，触发修正**
  - `data-theme` 与 `class` 不一致 → 触发属性更新；
  - 文本 `"：旧文案"` 与 `"：客户端更新文案"` 不一致 → 触发文本修正；
  - 类似“服务器提供预测值，客户端连上实时通道后更新最新读数”的过程。
- **案例 3：子节点数量变化与顺序错位**
  - 服务端提供 `A-B-C`，客户端期望 `B-A-D`；
  - 演示顺序错位（触发一次重建）与新增、删除的组合操作；
  - 可以映射到电力拓扑图：接入了新的馈线 D，同时 B、A 的排序被后台根据负荷重排。

### 调试技巧
- 把 `simulateHydration` 的输出保存到日志，对照浏览器中 React 提示的 Hydration Warning；
- 模拟 Suspense/RSC：在 `clientTree` 中插入 `#text` 节点或占位符，观察“缺失服务端节点”分支；
- 在 `diffProps` 中追加特殊处理（如事件绑定），体会 React 在水合阶段“仅绑定事件，不触发副作用”的设计。

## 场景分析与扩展练习

| 业务场景 | 推荐脚本 | 学习聚焦 | 实践建议 |
| --- | --- | --- | --- |
| 电力潮流计算结果列表同步 | `index.js` | 如何在前端列表里优雅地插入新节点/删除旧节点 | 将潮流计算的节点状态排序后同步到前端列表，观察是否只移动必要节点 |
| 新能源监控面板首屏渲染 | `hydrate_demo.js` | SSR + 客户端水合的差异同步 | 先 SSR 渲染基础数据，客户端拉实时数据后局部修正，关注 Hydration 警告 |
| Real-Time 系统事件流 | 两者结合 | Diff 算法配合水合修补实时事件列表 | 当服务器推送事件顺序不可控时，使用 key + LIS 减少重排，同时在水合阶段弹性处理缺失/新增 |

**扩展思路（“扩散”）**
1. **与实际框架对比**：阅读 React/Vue 源码中的 Diff 与 Hydration 模块，映射本脚本的伪代码与真实实现。
2. **引入性能计数**：给两个脚本增加计时逻辑，收集每一步耗时，直观感受 `O(n log n)` 与线性水合的效率。
3. **构建可视化工具**：把输出结果做成时序图或节点移动动画，更容易在团队培训中讲解。
4. **与电力仿真结合**：在客户端根据电网节点状态（矩阵）生成虚拟 DOM，再利用本脚本思路模拟刷新过程，验证大规模矩阵更新的稳定性。
5. **跨端同步**：考虑移动端或桌面端（例如 Electron），SSR 得到的 DOM 可能较旧，客户端 Hydration 时需要根据最新设备状态做补丁，可用本脚本扩展事件处理逻辑。

## 延伸阅读与思考题

1. **为什么 LIS 能在 O(n log n) 内算出最长稳定序列？**
   - 提示：观察 `tails` 数组在脚本中的作用，它记录了长度为 `len` 的递增序列里最小的尾元素。
2. **水合过程中，哪类副作用会被延迟执行？**
   - React 会把 `useEffect` 延迟到浏览器绘制后再执行；想象一个带动画的按钮 SSR 出来后，客户端何时才能真正启动动画？
3. **如果服务端与客户端的 key 规则不一致，会发生什么？**
   - 自行构造一个案例，观察 `hydrate_demo.js` 会如何处理错位；在真实框架中则往往触发 “Text content does not match server-rendered HTML” 的警告。
4. **如何在大规模节点管理中引入增量水合？**
   - 思考使用 “逐段水合（progressive hydration）” 或 “按需水合（selective hydration）” 的策略，结合这里的线性遍历思想实现分批补水。
5. **与线性代数的关系？**
   - 在处理电力仿真时，节点状态常来自矩阵求解。可以尝试把矩阵更新映射到列表/树结构，将数值变动通过 Diff/Hydration 快速同步到 UI。

---

如需进一步讨论某一案例或扩展脚本，请随时提出具体需求或业务场景，我可以继续协助设计实验方案。
