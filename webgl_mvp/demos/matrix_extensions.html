<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <title>矩阵工具扩展 · 缩放 + 任意轴旋转</title>
    <style>
      body {
        margin: 0;
        background: #0f172a;
        color: #e2e8f0;
        font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", san-serif;
        display: flex;
        flex-direction: column;
        min-height: 100vh;
      }

      header {
        padding: 20px 28px 10px;
      }

      h1 {
        margin: 0;
        font-size: 22px;
      }

      canvas {
        flex: 1;
        width: 100%;
        height: 100%;
        display: block;
      }

      .panel {
        padding: 16px 28px 26px;
        background: rgba(15, 23, 42, 0.86);
        border-top: 1px solid rgba(148, 163, 184, 0.18);
      }

      .panel p {
        margin: 0 0 12px;
        line-height: 1.6;
      }

      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(210px, 1fr));
        gap: 14px;
      }

      label {
        display: flex;
        flex-direction: column;
        gap: 6px;
        font-size: 14px;
      }

      input[type="range"] {
        accent-color: #f59e0b;
      }

      .axis-inputs {
        display: flex;
        gap: 8px;
      }

      .axis-inputs input {
        width: 100%;
        padding: 4px;
        border-radius: 4px;
        border: 1px solid rgba(148, 163, 184, 0.3);
        background: rgba(148, 163, 184, 0.1);
        color: #e2e8f0;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>矩阵扩展演示：缩放矩阵 + 任意轴旋转矩阵</h1>
      <p>
        这份示例在模型矩阵中引入 <code>mat4Scale</code> 和 <code>mat4RotateAxis</code>，并提供界面控制缩放、旋转轴与角度，帮助理解矩阵组合顺序。
      </p>
    </header>

    <canvas id="glCanvas"></canvas>

    <section class="panel">
      <p>提示：旋转轴会自动归一化；缩放可独立控制 XYZ 三个方向。</p>
      <div class="grid">
        <label>
          X 方向缩放
          <input id="scale-x" type="range" min="0.2" max="3" value="1" step="0.05" />
        </label>
        <label>
          Y 方向缩放
          <input id="scale-y" type="range" min="0.2" max="3" value="1.2" step="0.05" />
        </label>
        <label>
          Z 方向缩放
          <input id="scale-z" type="range" min="0.2" max="3" value="0.8" step="0.05" />
        </label>
        <label>
          旋转角度（度）
          <input id="axis-angle" type="range" min="0" max="360" value="120" />
        </label>
        <label>
          任意旋转轴分量（XYZ）
          <div class="axis-inputs">
            <input id="axis-x" type="number" value="1" step="0.1" />
            <input id="axis-y" type="number" value="1" step="0.1" />
            <input id="axis-z" type="number" value="0" step="0.1" />
          </div>
        </label>
      </div>
    </section>

    <script>
      // ======= 扩展矩阵工具函数集合 =======
      function mat4Identity() {
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      }

      function mat4Multiply(a, b) {
        const out = new Array(16);
        for (let i = 0; i < 4; i++) {
          const ai0 = a[i];
          const ai1 = a[i + 4];
          const ai2 = a[i + 8];
          const ai3 = a[i + 12];
          out[i] = ai0 * b[0] + ai1 * b[1] + ai2 * b[2] + ai3 * b[3];
          out[i + 4] = ai0 * b[4] + ai1 * b[5] + ai2 * b[6] + ai3 * b[7];
          out[i + 8] = ai0 * b[8] + ai1 * b[9] + ai2 * b[10] + ai3 * b[11];
          out[i + 12] = ai0 * b[12] + ai1 * b[13] + ai2 * b[14] + ai3 * b[15];
        }
        return out;
      }

      function mat4Scale(sx, sy, sz) {
        return [
          sx,
          0,
          0,
          0,
          0,
          sy,
          0,
          0,
          0,
          0,
          sz,
          0,
          0,
          0,
          0,
          1,
        ];
      }

      function mat4RotateAxis(rad, axis) {
        let [x, y, z] = axis;
        const len = Math.hypot(x, y, z);
        if (len < 1e-6) {
          return mat4Identity();
        }
        x /= len;
        y /= len;
        z /= len;

        const s = Math.sin(rad);
        const c = Math.cos(rad);
        const t = 1 - c;

        return [
          x * x * t + c,
          y * x * t + z * s,
          z * x * t - y * s,
          0,
          x * y * t - z * s,
          y * y * t + c,
          z * y * t + x * s,
          0,
          x * z * t + y * s,
          y * z * t - x * s,
          z * z * t + c,
          0,
          0,
          0,
          0,
          1,
        ];
      }

      function mat4RotationY(rad) {
        const c = Math.cos(rad);
        const s = Math.sin(rad);
        return [
          c,
          0,
          -s,
          0,
          0,
          1,
          0,
          0,
          s,
          0,
          c,
          0,
          0,
          0,
          0,
          1,
        ];
      }

      function mat4RotationX(rad) {
        const c = Math.cos(rad);
        const s = Math.sin(rad);
        return [
          1,
          0,
          0,
          0,
          0,
          c,
          s,
          0,
          0,
          -s,
          c,
          0,
          0,
          0,
          0,
          1,
        ];
      }

      function mat4Translation(tx, ty, tz) {
        const m = mat4Identity();
        m[12] = tx;
        m[13] = ty;
        m[14] = tz;
        return m;
      }

      function mat4Perspective(fovDeg, aspect, near, far) {
        const fovRad = (fovDeg * Math.PI) / 180;
        const f = 1 / Math.tan(fovRad / 2);
        const nf = 1 / (near - far);
        return [
          f / aspect,
          0,
          0,
          0,
          0,
          f,
          0,
          0,
          0,
          0,
          (far + near) * nf,
          -1,
          0,
          0,
          2 * far * near * nf,
          0,
        ];
      }

      function mat4LookAt(eye, target, up) {
        const [ex, ey, ez] = eye;
        const [tx, ty, tz] = target;
        const [ux, uy, uz] = up;

        let zx = ex - tx;
        let zy = ey - ty;
        let zz = ez - tz;
        let len = Math.hypot(zx, zy, zz);
        if (len === 0) {
          zx = 0;
          zy = 0;
          zz = 1;
        } else {
          zx /= len;
          zy /= len;
          zz /= len;
        }

        let xx = uy * zz - uz * zy;
        let xy = uz * zx - ux * zz;
        let xz = ux * zy - uy * zx;
        len = Math.hypot(xx, xy, xz);
        if (len !== 0) {
          xx /= len;
          xy /= len;
          xz /= len;
        }

        const yx = zy * xz - zz * xy;
        const yy = zz * xx - zx * xz;
        const yz = zx * xy - zy * xx;

        return [
          xx,
          yx,
          zx,
          0,
          xy,
          yy,
          zy,
          0,
          xz,
          yz,
          zz,
          0,
          -(xx * ex + xy * ey + xz * ez),
          -(yx * ex + yy * ey + yz * ez),
          -(zx * ex + zy * ey + zz * ez),
          1,
        ];
      }

      // ====== WebGL 初始化 ======
      const canvas = document.getElementById("glCanvas");
      const gl = canvas.getContext("webgl");
      if (!gl) {
        alert("当前浏览器不支持 WebGL");
        throw new Error("WebGL not supported");
      }

      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const width = Math.floor(canvas.clientWidth * dpr);
        const height = Math.floor(canvas.clientHeight * dpr);
        if (canvas.width !== width || canvas.height !== height) {
          canvas.width = width;
          canvas.height = height;
        }
        gl.viewport(0, 0, canvas.width, canvas.height);
      }

      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();

      const vsSource = `
        attribute vec3 aPosition;
        attribute vec3 aColor;
        uniform mat4 uModel;
        uniform mat4 uView;
        uniform mat4 uProjection;
        varying vec3 vColor;
        void main() {
          gl_Position = uProjection * uView * uModel * vec4(aPosition, 1.0);
          vColor = aColor;
        }
      `;

      const fsSource = `
        precision mediump float;
        varying vec3 vColor;
        void main() {
          gl_FragColor = vec4(vColor, 1.0);
        }
      `;

      function createShader(gl, type, src) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, src);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          const info = gl.getShaderInfoLog(shader);
          gl.deleteShader(shader);
          throw new Error("着色器编译失败：" + info);
        }
        return shader;
      }

      function createProgram(gl, vsSrc, fsSrc) {
        const program = gl.createProgram();
        const vs = createShader(gl, gl.VERTEX_SHADER, vsSrc);
        const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSrc);
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          const info = gl.getProgramInfoLog(program);
          gl.deleteProgram(program);
          throw new Error("Program 链接失败：" + info);
        }
        return program;
      }

      const program = createProgram(gl, vsSource, fsSource);
      gl.useProgram(program);

      const aPosition = gl.getAttribLocation(program, "aPosition");
      const aColor = gl.getAttribLocation(program, "aColor");
      const uModel = gl.getUniformLocation(program, "uModel");
      const uView = gl.getUniformLocation(program, "uView");
      const uProjection = gl.getUniformLocation(program, "uProjection");

      // 使用立方体几何，加强缩放/旋转后的形变感
      const positions = new Float32Array([
        -1, -1, 1,
        1, -1, 1,
        1, 1, 1,
        -1, 1, 1,
        -1, -1, -1,
        1, -1, -1,
        1, 1, -1,
        -1, 1, -1,
      ]);

      const colors = new Float32Array([
        0.96, 0.37, 0.4,
        0.96, 0.37, 0.4,
        0.96, 0.37, 0.4,
        0.96, 0.37, 0.4,
        0.35, 0.85, 0.95,
        0.35, 0.85, 0.95,
        0.35, 0.85, 0.95,
        0.35, 0.85, 0.95,
      ]);

      const indices = new Uint16Array([
        0, 1, 2,
        0, 2, 3,
        1, 5, 6,
        1, 6, 2,
        5, 4, 7,
        5, 7, 6,
        4, 0, 3,
        4, 3, 7,
        3, 2, 6,
        3, 6, 7,
        4, 5, 1,
        4, 1, 0,
      ]);

      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
      gl.enableVertexAttribArray(aPosition);
      gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);

      const colorBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
      gl.enableVertexAttribArray(aColor);
      gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0);

      const indexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

      gl.enable(gl.DEPTH_TEST);

      const scaleX = document.getElementById("scale-x");
      const scaleY = document.getElementById("scale-y");
      const scaleZ = document.getElementById("scale-z");
      const axisAngle = document.getElementById("axis-angle");
      const axisX = document.getElementById("axis-x");
      const axisY = document.getElementById("axis-y");
      const axisZ = document.getElementById("axis-z");

      function render(time) {
        resizeCanvas();
        gl.clearColor(0.04, 0.06, 0.16, 1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        const sx = Number(scaleX.value);
        const sy = Number(scaleY.value);
        const sz = Number(scaleZ.value);
        const angleRad = (Number(axisAngle.value) * Math.PI) / 180;
        const axis = [Number(axisX.value), Number(axisY.value), Number(axisZ.value)];

        const scaleMatrix = mat4Scale(sx, sy, sz);
        const axisMatrix = mat4RotateAxis(angleRad, axis);
        const autoY = mat4RotationY(time * 0.0006 * Math.PI * 2);
        const autoX = mat4RotationX(time * 0.0003 * Math.PI * 2);

        const rotationCombined = mat4Multiply(autoY, mat4Multiply(autoX, axisMatrix));
        const modelMatrix = mat4Multiply(rotationCombined, scaleMatrix);
        const worldMatrix = mat4Multiply(mat4Translation(0, 0, 0), modelMatrix);

        const viewMatrix = mat4LookAt([4, 4, 8], [0, 0, 0], [0, 1, 0]);
        const projectionMatrix = mat4Perspective(45, canvas.width / canvas.height, 0.1, 100);

        gl.uniformMatrix4fv(uModel, false, new Float32Array(worldMatrix));
        gl.uniformMatrix4fv(uView, false, new Float32Array(viewMatrix));
        gl.uniformMatrix4fv(uProjection, false, new Float32Array(projectionMatrix));

        gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);

        requestAnimationFrame(render);
      }

      requestAnimationFrame(render);
    </script>
  </body>
</html>
