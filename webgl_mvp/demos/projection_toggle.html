<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <title>透视投影 vs 正交投影 · 实时切换</title>
    <style>
      body {
        margin: 0;
        background: #111827;
        color: #f8fafc;
        font-family: "SF Pro Display", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        display: flex;
        flex-direction: column;
        min-height: 100vh;
      }

      header {
        padding: 20px 30px 10px;
      }

      h1 {
        margin: 0;
        font-size: 22px;
      }

      p {
        margin: 6px 0 0;
        line-height: 1.6;
      }

      canvas {
        flex: 1;
        width: 100%;
        height: 100%;
        display: block;
      }

      .panel {
        padding: 18px 30px 26px;
        background: rgba(17, 24, 39, 0.92);
        border-top: 1px solid rgba(96, 165, 250, 0.22);
      }

      .controls {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
        gap: 14px;
      }

      label {
        display: flex;
        flex-direction: column;
        gap: 6px;
        font-size: 14px;
      }

      input[type="range"] {
        accent-color: #38bdf8;
      }

      button {
        padding: 10px 16px;
        border-radius: 6px;
        border: 1px solid rgba(96, 165, 250, 0.5);
        background: rgba(59, 130, 246, 0.16);
        color: #f8fafc;
        cursor: pointer;
        transition: background 0.2s ease;
      }

      button:hover {
        background: rgba(96, 165, 250, 0.25);
      }

      .badge {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 10px;
        border-radius: 999px;
        background: rgba(56, 189, 248, 0.18);
        color: #bae6fd;
        font-size: 12px;
        margin-left: 12px;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>
        透视 / 正交 投影实时切换
        <span id="mode-badge" class="badge"></span>
      </h1>
      <p>点击按钮即可在两种投影矩阵之间切换，观察“近大远小”是否存在。</p>
    </header>

    <canvas id="glCanvas"></canvas>

    <section class="panel">
      <div class="controls">
        <div>
          <button id="toggle-mode">切换到正交投影</button>
        </div>
        <label id="persp-control">
          透视视角（FOV，度）
          <input id="fov-slider" type="range" min="20" max="100" value="60" />
        </label>
        <label id="ortho-control" style="display: none">
          正交视体宽度（数值越大场景越小）
          <input id="ortho-slider" type="range" min="2" max="20" value="8" step="0.1" />
        </label>
      </div>
    </section>

    <script>
      // ===== 矩阵工具 =====
      function mat4Multiply(a, b) {
        const out = new Array(16);
        for (let i = 0; i < 4; i++) {
          const ai0 = a[i];
          const ai1 = a[i + 4];
          const ai2 = a[i + 8];
          const ai3 = a[i + 12];
          out[i] = ai0 * b[0] + ai1 * b[1] + ai2 * b[2] + ai3 * b[3];
          out[i + 4] = ai0 * b[4] + ai1 * b[5] + ai2 * b[6] + ai3 * b[7];
          out[i + 8] = ai0 * b[8] + ai1 * b[9] + ai2 * b[10] + ai3 * b[11];
          out[i + 12] = ai0 * b[12] + ai1 * b[13] + ai2 * b[14] + ai3 * b[15];
        }
        return out;
      }

      function mat4RotationY(rad) {
        const c = Math.cos(rad);
        const s = Math.sin(rad);
        return [
          c,
          0,
          -s,
          0,
          0,
          1,
          0,
          0,
          s,
          0,
          c,
          0,
          0,
          0,
          0,
          1,
        ];
      }

      function mat4RotationX(rad) {
        const c = Math.cos(rad);
        const s = Math.sin(rad);
        return [
          1,
          0,
          0,
          0,
          0,
          c,
          s,
          0,
          0,
          -s,
          c,
          0,
          0,
          0,
          0,
          1,
        ];
      }

      function mat4Perspective(fovDeg, aspect, near, far) {
        const fovRad = (fovDeg * Math.PI) / 180;
        const f = 1 / Math.tan(fovRad / 2);
        const nf = 1 / (near - far);
        return [
          f / aspect,
          0,
          0,
          0,
          0,
          f,
          0,
          0,
          0,
          0,
          (far + near) * nf,
          -1,
          0,
          0,
          2 * far * near * nf,
          0,
        ];
      }

      function mat4Ortho(left, right, bottom, top, near, far) {
        const lr = 1 / (left - right);
        const bt = 1 / (bottom - top);
        const nf = 1 / (near - far);
        return [
          -2 * lr,
          0,
          0,
          0,
          0,
          -2 * bt,
          0,
          0,
          0,
          0,
          2 * nf,
          0,
          (left + right) * lr,
          (top + bottom) * bt,
          (far + near) * nf,
          1,
        ];
      }

      function mat4LookAt(eye, target, up) {
        const [ex, ey, ez] = eye;
        const [tx, ty, tz] = target;
        const [ux, uy, uz] = up;

        let zx = ex - tx;
        let zy = ey - ty;
        let zz = ez - tz;
        let len = Math.hypot(zx, zy, zz);
        if (len === 0) {
          zx = 0;
          zy = 0;
          zz = 1;
        } else {
          zx /= len;
          zy /= len;
          zz /= len;
        }

        let xx = uy * zz - uz * zy;
        let xy = uz * zx - ux * zz;
        let xz = ux * zy - uy * zx;
        len = Math.hypot(xx, xy, xz);
        if (len !== 0) {
          xx /= len;
          xy /= len;
          xz /= len;
        }

        const yx = zy * xz - zz * xy;
        const yy = zz * xx - zx * xz;
        const yz = zx * xy - zy * xx;

        return [
          xx,
          yx,
          zx,
          0,
          xy,
          yy,
          zy,
          0,
          xz,
          yz,
          zz,
          0,
          -(xx * ex + xy * ey + xz * ez),
          -(yx * ex + yy * ey + yz * ez),
          -(zx * ex + zy * ey + zz * ez),
          1,
        ];
      }

      // ===== WebGL 初始化 =====
      const canvas = document.getElementById("glCanvas");
      const gl = canvas.getContext("webgl");
      if (!gl) {
        alert("当前浏览器不支持 WebGL");
        throw new Error("WebGL not supported");
      }

      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const width = Math.floor(canvas.clientWidth * dpr);
        const height = Math.floor(canvas.clientHeight * dpr);
        if (canvas.width !== width || canvas.height !== height) {
          canvas.width = width;
          canvas.height = height;
        }
        gl.viewport(0, 0, canvas.width, canvas.height);
      }

      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();

      const vsSource = `
        attribute vec3 aPosition;
        attribute vec3 aColor;
        uniform mat4 uModel;
        uniform mat4 uView;
        uniform mat4 uProjection;
        varying vec3 vColor;
        void main() {
          gl_Position = uProjection * uView * uModel * vec4(aPosition, 1.0);
          vColor = aColor;
        }
      `;

      const fsSource = `
        precision mediump float;
        varying vec3 vColor;
        void main() {
          gl_FragColor = vec4(vColor, 1.0);
        }
      `;

      function createShader(gl, type, src) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, src);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          const info = gl.getShaderInfoLog(shader);
          gl.deleteShader(shader);
          throw new Error("着色器编译失败：" + info);
        }
        return shader;
      }

      function createProgram(gl, vsSrc, fsSrc) {
        const program = gl.createProgram();
        const vs = createShader(gl, gl.VERTEX_SHADER, vsSrc);
        const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSrc);
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          const info = gl.getProgramInfoLog(program);
          gl.deleteProgram(program);
          throw new Error("Program 链接失败：" + info);
        }
        return program;
      }

      const program = createProgram(gl, vsSource, fsSource);
      gl.useProgram(program);

      const aPosition = gl.getAttribLocation(program, "aPosition");
      const aColor = gl.getAttribLocation(program, "aColor");
      const uModel = gl.getUniformLocation(program, "uModel");
      const uView = gl.getUniformLocation(program, "uView");
      const uProjection = gl.getUniformLocation(program, "uProjection");

      const positions = new Float32Array([
        -1, -1, 1,
        1, -1, 1,
        1, 1, 1,
        -1, 1, 1,
        -1, -1, -1,
        1, -1, -1,
        1, 1, -1,
        -1, 1, -1,
      ]);

      const colors = new Float32Array([
        0.95, 0.45, 0.5,
        0.95, 0.45, 0.5,
        0.95, 0.45, 0.5,
        0.95, 0.45, 0.5,
        0.35, 0.8, 0.95,
        0.35, 0.8, 0.95,
        0.35, 0.8, 0.95,
        0.35, 0.8, 0.95,
      ]);

      const indices = new Uint16Array([
        0, 1, 2,
        0, 2, 3,
        1, 5, 6,
        1, 6, 2,
        5, 4, 7,
        5, 7, 6,
        4, 0, 3,
        4, 3, 7,
        3, 2, 6,
        3, 6, 7,
        4, 5, 1,
        4, 1, 0,
      ]);

      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
      gl.enableVertexAttribArray(aPosition);
      gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);

      const colorBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
      gl.enableVertexAttribArray(aColor);
      gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0);

      const indexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

      gl.enable(gl.DEPTH_TEST);

      const toggleBtn = document.getElementById("toggle-mode");
      const badge = document.getElementById("mode-badge");
      const perspControl = document.getElementById("persp-control");
      const orthoControl = document.getElementById("ortho-control");
      const fovSlider = document.getElementById("fov-slider");
      const orthoSlider = document.getElementById("ortho-slider");

      let projectionMode = "perspective";

      function updateModeUI() {
        if (projectionMode === "perspective") {
          toggleBtn.textContent = "切换到正交投影";
          badge.textContent = "当前：透视投影";
          perspControl.style.display = "block";
          orthoControl.style.display = "none";
        } else {
          toggleBtn.textContent = "切换到透视投影";
          badge.textContent = "当前：正交投影";
          perspControl.style.display = "none";
          orthoControl.style.display = "block";
        }
      }

      updateModeUI();

      toggleBtn.addEventListener("click", () => {
        projectionMode = projectionMode === "perspective" ? "orthographic" : "perspective";
        updateModeUI();
      });

      function render(time) {
        resizeCanvas();
        gl.clearColor(0.06, 0.09, 0.18, 1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        const t = time / 1000;
        const model = mat4Multiply(mat4RotationY(t * 0.7), mat4RotationX(t * 0.3));
        const view = mat4LookAt([4, 3.5, 7], [0, 0, 0], [0, 1, 0]);

        const aspect = canvas.width / canvas.height;
        let projection;
        if (projectionMode === "perspective") {
          projection = mat4Perspective(Number(fovSlider.value), aspect, 0.1, 100);
        } else {
          const halfWidth = Number(orthoSlider.value) / 2;
          const halfHeight = halfWidth / aspect;
          projection = mat4Ortho(-halfWidth, halfWidth, -halfHeight, halfHeight, -50, 50);
        }

        gl.uniformMatrix4fv(uModel, false, new Float32Array(model));
        gl.uniformMatrix4fv(uView, false, new Float32Array(view));
        gl.uniformMatrix4fv(uProjection, false, new Float32Array(projection));

        gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);

        requestAnimationFrame(render);
      }

      requestAnimationFrame(render);
    </script>
  </body>
</html>
