<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <title>正交投影对比示例 · MVP</title>
    <style>
      body {
        margin: 0;
        background: #0b1120;
        color: #e2e8f0;
        font-family: "HarmonyOS Sans", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        display: flex;
        flex-direction: column;
        min-height: 100vh;
      }

      header {
        padding: 18px 28px 8px;
      }

      h1 {
        margin: 0;
        font-size: 22px;
      }

      canvas {
        flex: 1;
        width: 100%;
        height: 100%;
        display: block;
      }

      .panel {
        padding: 16px 28px 24px;
        background: rgba(11, 17, 32, 0.92);
        border-top: 1px solid rgba(96, 165, 250, 0.25);
      }

      .panel p {
        margin: 0 0 12px;
        line-height: 1.6;
      }

      label {
        display: flex;
        flex-direction: column;
        gap: 6px;
        font-size: 14px;
      }

      input[type="range"] {
        accent-color: #38bdf8;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>使用正交投影（无透视缩放）观察旋转立方体</h1>
      <p>调节“视体宽度”即可看到物体大小几乎保持一致，体现正交投影不具备“近大远小”。</p>
    </header>

    <canvas id="glCanvas"></canvas>

    <section class="panel">
      <p>提示：尝试把视体缩放为很大值，仍不会出现透视变形。</p>
      <label>
        正交视体宽度（越大越远，单位与立方体边长一致）
        <input id="view-size" type="range" min="2" max="18" value="6" step="0.1" />
      </label>
    </section>

    <script>
      /*
       * 重点：理解正交投影矩阵
       * ---------------------------------------
       * 1. 与透视不同，正交视锥不会产生近大远小，适合绘制工程、平面配电图等。
       * 2. 通过滑块改变“视体宽度”，观察物体保持原始尺寸，只是被整体缩放。
       * 3. 渲染循环里将透视矩阵替换为 mat4Ortho，同步解释视体六个平面的含义。
       */
      // ===== 通用矩阵函数 =====
      function mat4Identity() {
        // 单位矩阵：不对坐标做任何处理。
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      }

      function mat4Multiply(a, b) {
        // 列主序矩阵乘法，用于组合多个变换。
        const out = new Array(16);
        for (let i = 0; i < 4; i++) {
          const ai0 = a[i];
          const ai1 = a[i + 4];
          const ai2 = a[i + 8];
          const ai3 = a[i + 12];
          out[i] = ai0 * b[0] + ai1 * b[1] + ai2 * b[2] + ai3 * b[3];
          out[i + 4] = ai0 * b[4] + ai1 * b[5] + ai2 * b[6] + ai3 * b[7];
          out[i + 8] = ai0 * b[8] + ai1 * b[9] + ai2 * b[10] + ai3 * b[11];
          out[i + 12] = ai0 * b[12] + ai1 * b[13] + ai2 * b[14] + ai3 * b[15];
        }
        return out;
      }

      function mat4Rotation(axis, rad) {
        // 根据轴向构建旋转矩阵，便于生成组合姿态。
        const c = Math.cos(rad);
        const s = Math.sin(rad);
        if (axis === "x") {
          return [
            1,
            0,
            0,
            0,
            0,
            c,
            s,
            0,
            0,
            -s,
            c,
            0,
            0,
            0,
            0,
            1,
          ];
        }
        if (axis === "y") {
          return [
            c,
            0,
            -s,
            0,
            0,
            1,
            0,
            0,
            s,
            0,
            c,
            0,
            0,
            0,
            0,
            1,
          ];
        }
        return mat4Identity();
      }

      function mat4LookAt(eye, target, up) {
        // 摄像机视图矩阵：定义观察点、目标点与上方向。
        const [ex, ey, ez] = eye;
        const [tx, ty, tz] = target;
        const [ux, uy, uz] = up;

        let zx = ex - tx;
        let zy = ey - ty;
        let zz = ez - tz;
        let len = Math.hypot(zx, zy, zz);
        if (len === 0) {
          zx = 0;
          zy = 0;
          zz = 1;
        } else {
          zx /= len;
          zy /= len;
          zz /= len;
        }

        let xx = uy * zz - uz * zy;
        let xy = uz * zx - ux * zz;
        let xz = ux * zy - uy * zx;
        len = Math.hypot(xx, xy, xz);
        if (len !== 0) {
          xx /= len;
          xy /= len;
          xz /= len;
        }

        const yx = zy * xz - zz * xy;
        const yy = zz * xx - zx * xz;
        const yz = zx * xy - zy * xx;

        return [
          xx,
          yx,
          zx,
          0,
          xy,
          yy,
          zy,
          0,
          xz,
          yz,
          zz,
          0,
          -(xx * ex + xy * ey + xz * ez),
          -(yx * ex + yy * ey + yz * ez),
          -(zx * ex + zy * ey + zz * ez),
          1,
        ];
      }

      function mat4Ortho(left, right, bottom, top, near, far) {
        // 正交投影矩阵：直接把长方体视体映射到裁剪空间。
        const lr = 1 / (left - right);
        const bt = 1 / (bottom - top);
        const nf = 1 / (near - far);
        return [
          -2 * lr,
          0,
          0,
          0,
          0,
          -2 * bt,
          0,
          0,
          0,
          0,
          2 * nf,
          0,
          (left + right) * lr,
          (top + bottom) * bt,
          (far + near) * nf,
          1,
        ];
      }

      // ===== WebGL 初始化 =====
      const canvas = document.getElementById("glCanvas");
      const gl = canvas.getContext("webgl");
      if (!gl) {
        alert("当前浏览器不支持 WebGL");
        throw new Error("WebGL not supported");
      }

      function resizeCanvas() {
        // 针对不同设备像素比调整画布尺寸。
        const dpr = window.devicePixelRatio || 1;
        const width = Math.floor(canvas.clientWidth * dpr);
        const height = Math.floor(canvas.clientHeight * dpr);
        if (canvas.width !== width || canvas.height !== height) {
          canvas.width = width;
          canvas.height = height;
        }
        gl.viewport(0, 0, canvas.width, canvas.height);
      }

      window.addEventListener("resize", resizeCanvas); // 监听窗口变化，保持视口与画布同步。
      resizeCanvas(); // 初始化时先执行一次调整。

      const vsSource = `
        attribute vec3 aPosition;
        attribute vec3 aColor;
        uniform mat4 uModel;
        uniform mat4 uView;
        uniform mat4 uProjection;
        varying vec3 vColor;
        void main() {
          gl_Position = uProjection * uView * uModel * vec4(aPosition, 1.0);
          vColor = aColor;
        }
      `;

      const fsSource = `
        precision mediump float;
        varying vec3 vColor;
        void main() {
          gl_FragColor = vec4(vColor, 1.0);
        }
      `;

      function createShader(gl, type, src) {
        // 编译着色器并输出中文错误信息。
        const shader = gl.createShader(type);
        gl.shaderSource(shader, src);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          const info = gl.getShaderInfoLog(shader);
          gl.deleteShader(shader);
          throw new Error("着色器编译失败：" + info);
        }
        return shader;
      }

      function createProgram(gl, vsSrc, fsSrc) {
        // 将顶点/片段着色器绑定到同一个管线。
        const program = gl.createProgram();
        const vs = createShader(gl, gl.VERTEX_SHADER, vsSrc);
        const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSrc);
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          const info = gl.getProgramInfoLog(program);
          gl.deleteProgram(program);
          throw new Error("Program 链接失败：" + info);
        }
        return program;
      }

      const program = createProgram(gl, vsSource, fsSource);
      gl.useProgram(program);

      // Attribute / Uniform 位置：用于绑定缓冲与上传矩阵。
      const aPosition = gl.getAttribLocation(program, "aPosition");
      const aColor = gl.getAttribLocation(program, "aColor");
      const uModel = gl.getUniformLocation(program, "uModel");
      const uView = gl.getUniformLocation(program, "uView");
      const uProjection = gl.getUniformLocation(program, "uProjection");

      // 立方体顶点与颜色
      const positions = new Float32Array([
        -1, -1, 1,
        1, -1, 1,
        1, 1, 1,
        -1, 1, 1,
        -1, -1, -1,
        1, -1, -1,
        1, 1, -1,
        -1, 1, -1,
      ]);

      const colors = new Float32Array([
        0.95, 0.42, 0.4,
        0.95, 0.42, 0.4,
        0.95, 0.42, 0.4,
        0.95, 0.42, 0.4,
        0.3, 0.8, 0.9,
        0.3, 0.8, 0.9,
        0.3, 0.8, 0.9,
        0.3, 0.8, 0.9,
      ]);

      const indices = new Uint16Array([
        0, 1, 2,
        0, 2, 3,
        1, 5, 6,
        1, 6, 2,
        5, 4, 7,
        5, 7, 6,
        4, 0, 3,
        4, 3, 7,
        3, 2, 6,
        3, 6, 7,
        4, 5, 1,
        4, 1, 0,
      ]);

      // 顶点缓冲：提供立方体的 8 个顶点。
      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
      gl.enableVertexAttribArray(aPosition);
      gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);

      // 颜色缓冲：为每个顶点指定两组对比色。
      const colorBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
      gl.enableVertexAttribArray(aColor);
      gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0);

      // 索引缓冲：按照三角形顺序绘制所有面。
      const indexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

      gl.enable(gl.DEPTH_TEST); // 确保近处面遮挡远处面。

      const sizeSlider = document.getElementById("view-size"); // 控制正交视体宽度。

      function render(time) {
        resizeCanvas();
        gl.clearColor(0.03, 0.05, 0.11, 1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        const t = time / 1000;
        const model = mat4Multiply(mat4Rotation("y", t * 0.7), mat4Rotation("x", t * 0.4));
        const view = mat4LookAt([4, 4, 4], [0, 0, 0], [0, 1, 0]);

        const halfWidth = Number(sizeSlider.value) / 2;
        const aspect = canvas.width / canvas.height;
        const halfHeight = halfWidth / aspect;
        // 正交投影：通过控制视体大小来改变可见范围，而非透视缩放。
        const projection = mat4Ortho(-halfWidth, halfWidth, -halfHeight, halfHeight, -20, 20);

        gl.uniformMatrix4fv(uModel, false, new Float32Array(model));
        gl.uniformMatrix4fv(uView, false, new Float32Array(view));
        gl.uniformMatrix4fv(uProjection, false, new Float32Array(projection));

        gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0); // 采用索引方式绘制立方体。

        requestAnimationFrame(render);
      }

      requestAnimationFrame(render); // 启动持续渲染。
    </script>
  </body>
</html>
