<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <title>模型矩阵平移体验 · MVP 示例</title>
    <style>
      body {
        margin: 0;
        background: #111827;
        color: #f1f5f9;
        font-family: "PingFang SC", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        display: flex;
        flex-direction: column;
        min-height: 100vh;
      }

      header {
        padding: 18px 26px 8px;
      }

      h1 {
        margin: 0;
        font-size: 21px;
      }

      canvas {
        flex: 1;
        width: 100%;
        height: 100%;
        display: block;
      }

      .panel {
        padding: 16px 26px 22px;
        background: rgba(17, 24, 39, 0.88);
        border-top: 1px solid rgba(99, 102, 241, 0.2);
      }

      .panel p {
        margin: 0 0 12px;
        line-height: 1.6;
      }

      .grid {
        display: grid;
        gap: 12px;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      }

      label {
        display: flex;
        flex-direction: column;
        gap: 6px;
        font-size: 14px;
      }

      input[type="range"] {
        accent-color: #6366f1;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>通过模型矩阵平移控制物体位置</h1>
      <p>拖动滑块分别沿 X / Y / Z 方向平移，观察同一立方体在世界坐标中的位移效果。</p>
    </header>

    <canvas id="glCanvas"></canvas>

    <section class="panel">
      <p>平移值单位与立方体边长一致（边长约 2）。</p>
      <div class="grid">
        <label>
          沿 X 轴平移
          <input id="translate-x" type="range" min="-5" max="5" value="0" step="0.1" />
        </label>
        <label>
          沿 Y 轴平移
          <input id="translate-y" type="range" min="-5" max="5" value="0" step="0.1" />
        </label>
        <label>
          沿 Z 轴平移
          <input id="translate-z" type="range" min="-12" max="2" value="-4" step="0.1" />
        </label>
      </div>
    </section>

    <script>
      /*
       * 练习目标：掌握模型矩阵的平移部分
       * ---------------------------------------
       * 1. 矩阵工具：保留最小集合（单位矩阵、乘法、平移、旋转、透视、LookAt）。
       * 2. UI 控件：三个滑块直接对应平移向量 (tx, ty, tz)。
       * 3. 渲染循环：将平移矩阵与自旋矩阵相乘，观察结果如何影响立方体位置。
       */
      // ===== 常用矩阵工具 =====
      function mat4Identity() {
        // 单位矩阵：作为无变换的起点。
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      }

      function mat4Multiply(a, b) {
        // 列主序矩阵乘法：组合多个模型变换。
        const out = new Array(16);
        for (let i = 0; i < 4; i++) {
          const ai0 = a[i];
          const ai1 = a[i + 4];
          const ai2 = a[i + 8];
          const ai3 = a[i + 12];
          out[i] = ai0 * b[0] + ai1 * b[1] + ai2 * b[2] + ai3 * b[3];
          out[i + 4] = ai0 * b[4] + ai1 * b[5] + ai2 * b[6] + ai3 * b[7];
          out[i + 8] = ai0 * b[8] + ai1 * b[9] + ai2 * b[10] + ai3 * b[11];
          out[i + 12] = ai0 * b[12] + ai1 * b[13] + ai2 * b[14] + ai3 * b[15];
        }
        return out;
      }

      function mat4Translation(tx, ty, tz) {
        // 平移矩阵：把对象沿 XYZ 三方向移动。
        const m = mat4Identity();
        m[12] = tx;
        m[13] = ty;
        m[14] = tz;
        return m;
      }

      function mat4RotationY(rad) {
        // 绕 Y 轴旋转，用于保持立方体自旋。
        const c = Math.cos(rad);
        const s = Math.sin(rad);
        return [
          c,
          0,
          -s,
          0,
          0,
          1,
          0,
          0,
          s,
          0,
          c,
          0,
          0,
          0,
          0,
          1,
        ];
      }

      function mat4Perspective(fovDeg, aspect, near, far) {
        // 透视投影矩阵：实现“近大远小”。
        const fovRad = (fovDeg * Math.PI) / 180;
        const f = 1 / Math.tan(fovRad / 2);
        const nf = 1 / (near - far);
        return [
          f / aspect,
          0,
          0,
          0,
          0,
          f,
          0,
          0,
          0,
          0,
          (far + near) * nf,
          -1,
          0,
          0,
          2 * far * near * nf,
          0,
        ];
      }

      function mat4LookAt(eye, target, up) {
        // 视图矩阵：从摄像机坐标系观察场景。
        const [ex, ey, ez] = eye;
        const [tx, ty, tz] = target;
        const [ux, uy, uz] = up;

        let zx = ex - tx;
        let zy = ey - ty;
        let zz = ez - tz;
        let len = Math.hypot(zx, zy, zz);
        if (len === 0) {
          zx = 0;
          zy = 0;
          zz = 1;
        } else {
          zx /= len;
          zy /= len;
          zz /= len;
        }

        let xx = uy * zz - uz * zy;
        let xy = uz * zx - ux * zz;
        let xz = ux * zy - uy * zx;
        len = Math.hypot(xx, xy, xz);
        if (len !== 0) {
          xx /= len;
          xy /= len;
          xz /= len;
        }

        const yx = zy * xz - zz * xy;
        const yy = zz * xx - zx * xz;
        const yz = zx * xy - zy * xx;

        return [
          xx,
          yx,
          zx,
          0,
          xy,
          yy,
          zy,
          0,
          xz,
          yz,
          zz,
          0,
          -(xx * ex + xy * ey + xz * ez),
          -(yx * ex + yy * ey + yz * ez),
          -(zx * ex + zy * ey + zz * ez),
          1,
        ];
      }

      // ===== WebGL 初始化 =====
      const canvas = document.getElementById("glCanvas");
      const gl = canvas.getContext("webgl");
      if (!gl) {
        alert("当前浏览器不支持 WebGL");
        throw new Error("WebGL not supported");
      }

      function resizeCanvas() {
        // 自动匹配设备像素比，保证渲染清晰。
        const dpr = window.devicePixelRatio || 1;
        const width = Math.floor(canvas.clientWidth * dpr);
        const height = Math.floor(canvas.clientHeight * dpr);
        if (canvas.width !== width || canvas.height !== height) {
          canvas.width = width;
          canvas.height = height;
        }
        gl.viewport(0, 0, canvas.width, canvas.height);
      }

      window.addEventListener("resize", resizeCanvas); // 监听窗口变化。
      resizeCanvas(); // 初次运行时设置画布尺寸。

      const vsSource = `
        attribute vec3 aPosition;
        attribute vec3 aColor;
        uniform mat4 uModel;
        uniform mat4 uView;
        uniform mat4 uProjection;
        varying vec3 vColor;
        void main() {
          gl_Position = uProjection * uView * uModel * vec4(aPosition, 1.0);
          vColor = aColor;
        }
      `;

      const fsSource = `
        precision mediump float;
        varying vec3 vColor;
        void main() {
          gl_FragColor = vec4(vColor, 1.0);
        }
      `;

      function createShader(gl, type, src) {
        // 工具函数：编译失败时抛出中文错误信息。
        const shader = gl.createShader(type);
        gl.shaderSource(shader, src);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          const info = gl.getShaderInfoLog(shader);
          gl.deleteShader(shader);
          throw new Error("着色器编译失败：" + info);
        }
        return shader;
      }

      function createProgram(gl, vsSrc, fsSrc) {
        // 将顶点/片段着色器链接到同一 Program。
        const program = gl.createProgram();
        const vs = createShader(gl, gl.VERTEX_SHADER, vsSrc);
        const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSrc);
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          const info = gl.getProgramInfoLog(program);
          gl.deleteProgram(program);
          throw new Error("Program 链接失败：" + info);
        }
        return program;
      }

      const program = createProgram(gl, vsSource, fsSource);
      gl.useProgram(program);

      // Attribute / Uniform 位置：后续缓冲绑定与矩阵上传都依赖这些句柄。
      const aPosition = gl.getAttribLocation(program, "aPosition");
      const aColor = gl.getAttribLocation(program, "aColor");
      const uModel = gl.getUniformLocation(program, "uModel");
      const uView = gl.getUniformLocation(program, "uView");
      const uProjection = gl.getUniformLocation(program, "uProjection");

      // ===== 立方体顶点与颜色 =====
      const positions = new Float32Array([
        // 前面
        -1, -1, 1,
        1, -1, 1,
        1, 1, 1,
        -1, 1, 1,
        // 后面
        -1, -1, -1,
        1, -1, -1,
        1, 1, -1,
        -1, 1, -1,
      ]);

      const colors = new Float32Array([
        1, 0.4, 0.4,
        1, 0.4, 0.4,
        1, 0.4, 0.4,
        1, 0.4, 0.4,
        0.4, 0.7, 1,
        0.4, 0.7, 1,
        0.4, 0.7, 1,
        0.4, 0.7, 1,
      ]);

      const indices = new Uint16Array([
        0, 1, 2,
        0, 2, 3,
        1, 5, 6,
        1, 6, 2,
        5, 4, 7,
        5, 7, 6,
        4, 0, 3,
        4, 3, 7,
        3, 2, 6,
        3, 6, 7,
        4, 5, 1,
        4, 1, 0,
      ]);

      // 顶点缓冲：存储所有顶点坐标。
      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
      gl.enableVertexAttribArray(aPosition);
      gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);

      // 颜色缓冲：为每个顶点提供插值颜色。
      const colorBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
      gl.enableVertexAttribArray(aColor);
      gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0);

      // 索引缓冲：通过重用顶点减少数据量。
      const indexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

      gl.enable(gl.DEPTH_TEST); // 避免后方面遮挡前方面。

      // 滑块控件：直接对应平移向量 (tx, ty, tz)。
      const sliderX = document.getElementById("translate-x");
      const sliderY = document.getElementById("translate-y");
      const sliderZ = document.getElementById("translate-z");

      function render(time) {
        resizeCanvas();
        gl.clearColor(0.05, 0.06, 0.1, 1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // 模型矩阵 = 平移 * 自旋
        const spin = (time / 1000) * 0.5;
        const rotation = mat4RotationY(spin);
        const translation = mat4Translation(
          Number(sliderX.value),
          Number(sliderY.value),
          Number(sliderZ.value)
        );
        const model = mat4Multiply(translation, rotation); // 平移放在左侧，先旋转后移动。

        const view = mat4LookAt([0, 2, 12], [0, 0, 0], [0, 1, 0]);
        const projection = mat4Perspective(45, canvas.width / canvas.height, 0.1, 100);

        gl.uniformMatrix4fv(uModel, false, new Float32Array(model));
        gl.uniformMatrix4fv(uView, false, new Float32Array(view));
        gl.uniformMatrix4fv(uProjection, false, new Float32Array(projection));

        gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0); // 绘制所有三角面。
        requestAnimationFrame(render);
      }

      requestAnimationFrame(render); // 启动动画循环。
    </script>
  </body>
</html>
