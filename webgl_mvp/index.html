<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <title>WebGL MVP 可视化示例</title>
    <style>
      body {
        margin: 0;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background: #0f172a;
        color: #e2e8f0;
        display: flex;
        flex-direction: column;
        min-height: 100vh;
      }

      header {
        padding: 16px 24px 8px;
      }

      h1 {
        margin: 0;
        font-size: 20px;
      }

      p {
        margin: 6px 0;
        line-height: 1.6;
      }

      canvas {
        flex: 1;
        width: 100%;
        height: 100%;
        display: block;
      }

      .panel {
        background: rgba(15, 23, 42, 0.85);
        border-top: 1px solid rgba(148, 163, 184, 0.14);
        padding: 12px 24px 20px;
      }

      .panel code {
        background: rgba(148, 163, 184, 0.12);
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 14px;
      }

      .sliders {
        display: grid;
        gap: 12px;
        margin-top: 12px;
      }

      label {
        display: flex;
        flex-direction: column;
        gap: 4px;
        font-size: 14px;
      }

      input[type="range"] {
        accent-color: #38bdf8;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>WebGL 中的 MVP（Model · View · Projection）矩阵</h1>
      <p>
        这个示例用一个旋转立方体演示「模型矩阵 → 视图矩阵 → 投影矩阵」的作用。
        你可以拖动滑块体验：<code>M</code> 控制模型旋转，<code>V</code> 调整摄像机位置，<code>P</code> 修改投影角度。
      </p>
    </header>

    <canvas id="glCanvas"></canvas>

    <section class="panel">
      <strong>交互操作：</strong>
      <div class="sliders">
        <label>
          模型旋转角度（围绕 Y 轴）
          <input id="model-rotation" type="range" min="0" max="360" value="45" />
        </label>

        <label>
          摄像机距离（View 矩阵，沿 Z 轴）
          <input id="camera-distance" type="range" min="2" max="20" value="6" step="0.1" />
        </label>

        <label>
          投影视角（Projection FOV）
          <input id="projection-fov" type="range" min="20" max="100" value="45" />
        </label>
      </div>
    </section>

    <script>
      /*
       * =======================================
       * 教程导读：如何快速理解本示例
       * ---------------------------------------
       * · 第一步：看懂布局 —— 顶部说明 + 中央 canvas + 底部控制面板。
       * · 第二步：掌握脚本分区 —— 矩阵工具 → WebGL 初始化 → 几何数据 → 交互控件 → 渲染循环。
       * · 第三步：配合滑块体验 MVP（Model/View/Projection）各自的作用。
       * 建议顺序：先关注模型矩阵如何旋转，再看视图矩阵改变摄像机位置，最后体验投影矩阵带来的透视变化。
       * =======================================
       */

      // ======== 工具函数区域：矩阵运算 ========
      // 小型 4x4 矩阵工具，满足本示例对 MVP 的需求（列主序，与 WebGL uniformMatrix4fv 对齐）。

      function mat4Identity() {
        // 单位矩阵：表示“保持原状”，在连乘里起到 neutral element 的作用。
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      }

      function mat4Multiply(a, b) {
        // 将矩阵 b 应用在矩阵 a 之后，返回新的组合矩阵（右乘模式）。
        const out = new Array(16);

        const a00 = a[0],
          a01 = a[1],
          a02 = a[2],
          a03 = a[3];
        const a10 = a[4],
          a11 = a[5],
          a12 = a[6],
          a13 = a[7];
        const a20 = a[8],
          a21 = a[9],
          a22 = a[10],
          a23 = a[11];
        const a30 = a[12],
          a31 = a[13],
          a32 = a[14],
          a33 = a[15];

        let b0, b1, b2, b3;

        b0 = b[0];
        b1 = b[1];
        b2 = b[2];
        b3 = b[3];
        out[0] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
        out[1] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
        out[2] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
        out[3] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;

        b0 = b[4];
        b1 = b[5];
        b2 = b[6];
        b3 = b[7];
        out[4] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
        out[5] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
        out[6] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
        out[7] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;

        b0 = b[8];
        b1 = b[9];
        b2 = b[10];
        b3 = b[11];
        out[8] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
        out[9] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
        out[10] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
        out[11] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;

        b0 = b[12];
        b1 = b[13];
        b2 = b[14];
        b3 = b[15];
        out[12] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
        out[13] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
        out[14] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
        out[15] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;

        return out;
      }

      function mat4Translation(tx, ty, tz) {
        // 平移矩阵：把模型整体沿 X/Y/Z 三个方向移动。
        const m = mat4Identity();
        m[12] = tx;
        m[13] = ty;
        m[14] = tz;
        return m;
      }

      function mat4RotationY(rad) {
        // 绕 Y 轴旋转：常用于模拟左右旋转。
        const c = Math.cos(rad);
        const s = Math.sin(rad);
        return [
          c,
          0,
          -s,
          0,
          0,
          1,
          0,
          0,
          s,
          0,
          c,
          0,
          0,
          0,
          0,
          1,
        ];
      }

      function mat4RotationX(rad) {
        // 绕 X 轴旋转：在此示例里制造“点头”式的自动旋转。
        const c = Math.cos(rad);
        const s = Math.sin(rad);
        return [
          1,
          0,
          0,
          0,
          0,
          c,
          s,
          0,
          0,
          -s,
          c,
          0,
          0,
          0,
          0,
          1,
        ];
      }

      function mat4Perspective(fovDeg, aspect, near, far) {
        // 透视投影矩阵：用于实现“近大远小”。
        const fovRad = (fovDeg * Math.PI) / 180;
        const f = 1 / Math.tan(fovRad / 2);
        const nf = 1 / (near - far);

        return [
          f / aspect,
          0,
          0,
          0,
          0,
          f,
          0,
          0,
          0,
          0,
          (far + near) * nf,
          -1,
          0,
          0,
          2 * far * near * nf,
          0,
        ];
      }

      function mat4LookAt(eye, target, up) {
        // 视图矩阵：计算从 eye 看向 target 时的摄像机坐标系。
        const [ex, ey, ez] = eye;
        const [tx, ty, tz] = target;
        const [ux, uy, uz] = up;

        let zx = ex - tx;
        let zy = ey - ty;
        let zz = ez - tz;
        let len = Math.hypot(zx, zy, zz);
        if (len === 0) {
          zx = 0;
          zy = 0;
          zz = 1;
        } else {
          zx /= len;
          zy /= len;
          zz /= len;
        }

        let xx = uy * zz - uz * zy;
        let xy = uz * zx - ux * zz;
        let xz = ux * zy - uy * zx;
        len = Math.hypot(xx, xy, xz);
        if (len === 0) {
          xx = 0;
          xy = 0;
          xz = 0;
        } else {
          xx /= len;
          xy /= len;
          xz /= len;
        }

        const yx = zy * xz - zz * xy;
        const yy = zz * xx - zx * xz;
        const yz = zx * xy - zy * xx;

        return [
          xx,
          yx,
          zx,
          0,
          xy,
          yy,
          zy,
          0,
          xz,
          yz,
          zz,
          0,
          -(xx * ex + xy * ey + xz * ez),
          -(yx * ex + yy * ey + yz * ez),
          -(zx * ex + zy * ey + zz * ez),
          1,
        ];
      }

      // ======== WebGL 初始化与渲染逻辑 ========

      const canvas = document.getElementById("glCanvas");
      const gl = canvas.getContext("webgl");

      if (!gl) {
        alert("当前浏览器不支持 WebGL");
        throw new Error("WebGL not supported");
      }

      function resizeCanvas() {
        // 根据设备像素比动态调整画布大小，避免在高分屏上失真。
        const devicePixelRatio = window.devicePixelRatio || 1;
        const displayWidth = Math.floor(canvas.clientWidth * devicePixelRatio);
        const displayHeight = Math.floor(canvas.clientHeight * devicePixelRatio);

        if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
          canvas.width = displayWidth;
          canvas.height = displayHeight;
        }

        gl.viewport(0, 0, canvas.width, canvas.height);
      }

      window.addEventListener("resize", resizeCanvas); // 窗口缩放时重新计算画布大小。
      resizeCanvas(); // 初始化调用一次，确保首次渲染正确。

      // 顶点着色器：输入顶点位置与颜色，输出裁剪空间坐标与传递给片段的颜色。
      const vertexShaderSource = `
        attribute vec3 aPosition;
        attribute vec3 aColor;
        uniform mat4 uModelMatrix;
        uniform mat4 uViewMatrix;
        uniform mat4 uProjectionMatrix;
        varying vec3 vColor;
        void main() {
          gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aPosition, 1.0);
          vColor = aColor;
        }
      `;

      // 片段着色器：接收插值后的颜色，直接绘制。
      const fragmentShaderSource = `
        precision mediump float;
        varying vec3 vColor;
        void main() {
          gl_FragColor = vec4(vColor, 1.0);
        }
      `;

      function createShader(gl, type, source) {
        // 编译着色器的通用函数，失败时抛出详细日志，便于入门者定位问题。
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          const info = gl.getShaderInfoLog(shader);
          gl.deleteShader(shader);
          throw new Error("着色器编译失败: " + info);
        }
        return shader;
      }

      function createProgram(gl, vsSource, fsSource) {
        // 连接顶点/片段着色器，形成一次完整的 GPU 渲染管线。
        const program = gl.createProgram();
        const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
        const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          const info = gl.getProgramInfoLog(program);
          gl.deleteProgram(program);
          throw new Error("Program 链接失败: " + info);
        }
        return program;
      }

      const program = createProgram(gl, vertexShaderSource, fragmentShaderSource);
      gl.useProgram(program);

      // Attribute / Uniform 位置查询：后续写入顶点缓冲或更新矩阵都依赖这些句柄。
      const positionLocation = gl.getAttribLocation(program, "aPosition");
      const colorLocation = gl.getAttribLocation(program, "aColor");
      const uModelMatrixLocation = gl.getUniformLocation(program, "uModelMatrix");
      const uViewMatrixLocation = gl.getUniformLocation(program, "uViewMatrix");
      const uProjectionMatrixLocation = gl.getUniformLocation(program, "uProjectionMatrix");

      // 创建一个带颜色的立方体：顶点坐标与颜色分离，便于分别调整。
      const positions = new Float32Array([
        // 前面
        -1, -1, 1,
        1, -1, 1,
        1, 1, 1,
        -1, 1, 1,
        // 后面
        -1, -1, -1,
        1, -1, -1,
        1, 1, -1,
        -1, 1, -1,
      ]);

      const colors = new Float32Array([
        // 前面 (洋红)
        1, 0, 1,
        1, 0, 1,
        1, 0, 1,
        1, 0, 1,
        // 后面 (青色)
        0, 1, 1,
        0, 1, 1,
        0, 1, 1,
        0, 1, 1,
      ]);

      const indices = new Uint16Array([
        // 前面
        0, 1, 2,
        0, 2, 3,
        // 右侧
        1, 5, 6,
        1, 6, 2,
        // 后面
        5, 4, 7,
        5, 7, 6,
        // 左侧
        4, 0, 3,
        4, 3, 7,
        // 顶部
        3, 2, 6,
        3, 6, 7,
        // 底部
        4, 5, 1,
        4, 1, 0,
      ]);

      // 顶点缓冲：把 position 数组一次性上传到 GPU，供 aPosition 属性读取。
      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
      gl.enableVertexAttribArray(positionLocation);
      gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);

      // 颜色缓冲：与位置类似，绑定到 aColor，传递给着色器插值。
      const colorBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
      gl.enableVertexAttribArray(colorLocation);
      gl.vertexAttribPointer(colorLocation, 3, gl.FLOAT, false, 0, 0);

      // 索引缓冲：ELEMENT_ARRAY_BUFFER 告诉 WebGL 如何复用顶点绘制三角形。
      const indexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

      gl.enable(gl.DEPTH_TEST); // 开启深度测试，确保遮挡关系正确。

      const modelSlider = document.getElementById("model-rotation");
      const cameraSlider = document.getElementById("camera-distance");
      const fovSlider = document.getElementById("projection-fov");

      function render(time) {
        resizeCanvas();

        gl.clearColor(0.02, 0.04, 0.1, 1); // 设置背景色（深蓝）。
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // 清空颜色与深度缓冲。

        const modelRotateY = (Number(modelSlider.value) * Math.PI) / 180;
        const autoRotateX = time * 0.0005; // 自动时间驱动的旋转，让场景动起来。

        // 模型矩阵：先自动绕 X 轴转，再根据滑块绕 Y 轴转。
        const modelMatrix = mat4Multiply(
          mat4RotationY(modelRotateY),
          mat4RotationX(autoRotateX)
        );

        // 视图矩阵：用摄像机位姿描述“我从哪里看场景”。
        const cameraDistance = Number(cameraSlider.value);
        const eye = [0, 1.8, cameraDistance];
        const target = [0, 0, 0];
        const up = [0, 1, 0];
        const viewMatrix = mat4LookAt(eye, target, up);

        // 投影矩阵：控制近大远小的透视效果。
        const aspect = canvas.width / canvas.height;
        const fov = Number(fovSlider.value);
        const projectionMatrix = mat4Perspective(fov, aspect, 0.1, 100);

        // 将最新计算的矩阵送入 GPU uniform，驱动顶点着色器变换。
        gl.uniformMatrix4fv(uModelMatrixLocation, false, new Float32Array(modelMatrix));
        gl.uniformMatrix4fv(uViewMatrixLocation, false, new Float32Array(viewMatrix));
        gl.uniformMatrix4fv(uProjectionMatrixLocation, false, new Float32Array(projectionMatrix));

        gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0); // 基于索引绘制全部面。

        requestAnimationFrame(render); // 循环调用 render，保持 60FPS 左右的动画。
      }

      requestAnimationFrame(render); // 启动动画主循环。
    </script>
  </body>
</html>
